import 'dart:html';

import 'package:angular/angular.dart';

import 'enums.dart';

// import { detectIE, calculateAutoPositioning } from './helpers';
//
// import { ColorFormats, Cmyk, Hsla, Hsva, Rgba } from './formats';
// import { AlphaChannel, OutputFormat, SliderDimension, SliderPosition } from './helpers';
//
// import { ColorPickerService } from './color-picker.service';

@Component(
  selector: 'color-picker',
  templateUrl: 'color-picker.component.html',
  styleUrls: [ 'color-picker.component.scss.css' ],
    encapsulation: ViewEncapsulation.None
)
class ColorPickerComponent implements OnInit, OnDestroy, AfterViewInit {
  bool _isIE10 = false;

  Cmyk _cmyk;
  Hsva _hsva;

  num width;
  num height;

  String cmykColor;
  String outputColor;
  String initialColor;
  String fallbackColor;

  Object listenerResize;
  Object listenerMouseDown;

  Object directiveInstance;

  num sliderH;
  SliderDimension sliderDimMax;
  ElementRef directiveElementRef;

  num dialogArrowSize = 10;
  num dialogArrowOffset = 15;

  final _dialogInputFields = [
    ColorFormats.HEX,
    ColorFormats.RGBA,
    ColorFormats.HSLA,
    ColorFormats.CMYK
  ];

  bool useRootViewContainer = false;

  bool show;
  bool hidden;

  num top;
  num left;
  String position;

  ColorFormats format;
  SliderPosition slider;

  String hexText;
  num hexAlpha;

  Cmyk cmykText;
  Hsla hslaText;
  Rgba rgbaText;

  num arrowTop;

  String selectedColor;
  String hueSliderColor;
  String alphaSliderColor;

  num cpWidth;
  num cpHeight;

  num cpColorMode;

  bool cpCmykEnabled;

  AlphaChannel cpAlphaChannel;
  OutputFormat cpOutputFormat;

  bool cpDisableInput;
  String cpDialogDisplay;

  Object cpIgnoredElements;

  bool cpSaveClickOutside;
  bool cpCloseClickOutside;

  String cpPosition;
  String cpUsePosition;
  num cpPositionOffset;

  bool cpOKButton;
  String cpOKButtonText;
  String cpOKButtonClass;

  bool cpCancelButton;
  String cpCancelButtonText;
  String cpCancelButtonClass;

  String cpPresetLabel;
  Iterable<String> cpPresetColors;

  String cpPresetColorsClass;
  num cpMaxPresetColorsLength;

  String cpPresetEmptyMessage;
  String cpPresetEmptyMessageClass;

  bool cpAddColorButton;
  String cpAddColorButtonText;
  String cpAddColorButtonClass;
  String cpRemoveColorButtonClass;

  ElementRef cpTriggerElement;

  @ViewChild('dialogPopup') ElementRef dialogElement;

  @ViewChild('hueSlider') ElementRef hueSlider;
  @ViewChild('alphaSlider') ElementRef alphaSlider;

  @HostListener('document:keyup.esc', [r'$event'])
  void handleEsc(Object event) {
    if (show && cpDialogDisplay == 'popup') {
      onCancelColor(event);
    }
  }

  @HostListener('document:keyup.enter', [r'$event'])
  void handleEnter(Object event) {
    if (show && cpDialogDisplay == 'popup') {
      onAcceptColor(event);
    }
  }

  ColorPickerComponent(ElementRef elRef, ChangeDetectorRef cdRef,
      ColorPickerService service);

  void ngOnInit() {
    slider = SliderPosition(0, 0, 0, 0);

    const hueWidth = hueSlider.nativeElement.offsetWidth ?? 140;
    const alphaWidth = alphaSlider.nativeElement.offsetWidth ?? 140;

    sliderDimMax = SliderDimension(hueWidth, cpWidth, 130, alphaWidth);

    if (cpCmykEnabled) {
      format = ColorFormats.CMYK;
    } else if (cpOutputFormat == 'rgba') {
      format = ColorFormats.RGBA;
    } else if (cpOutputFormat == 'hsla') {
      format = ColorFormats.HSLA;
    } else {
      format = ColorFormats.HEX;
    }

    listenerMouseDown = (Object event) {
      onMouseDown(event);
    };
    listenerResize = () {
      onResize();
    };

    openDialog(initialColor, false);
  }

  void ngOnDestroy() {
    closeDialog();
  }

  void ngAfterViewInit() {
    if (cpWidth != 230 || cpDialogDisplay == 'inline') {
      const hueWidth = hueSlider.nativeElement.offsetWidth ?? 140;
      const alphaWidth = alphaSlider.nativeElement.offsetWidth ?? 140;

      sliderDimMax = SliderDimension(hueWidth, cpWidth, 130, alphaWidth);

      updateColorPicker(false);

      cdRef.detectChanges();
    }
  }

  void setupDialog(Object instance, ElementRef elementRef, Object color,
      String cpWidth, String cpHeight, String cpDialogDisplay,
      String cpFallbackColor,
      String cpColorMode, bool cpCmykEnabled, AlphaChannel cpAlphaChannel,
      OutputFormat cpOutputFormat, bool cpDisableInput,
      Object cpIgnoredElements,
      bool cpSaveClickOutside, bool cpCloseClickOutside,
      bool cpUseRootViewContainer,
      String cpPosition, String cpPositionOffset,
      bool cpPositionRelativeToArrow,
      String cpPresetLabel, Iterable<String> cpPresetColors,
      String cpPresetColorsClass,
      num cpMaxPresetColorsLength, String cpPresetEmptyMessage,
      String cpPresetEmptyMessageClass, bool cpOKButton, String cpOKButtonClass,
      String cpOKButtonText, bool cpCancelButton, String cpCancelButtonClass,
      String cpCancelButtonText, bool cpAddColorButton,
      String cpAddColorButtonClass,
      String cpAddColorButtonText, String cpRemoveColorButtonClass,
      ElementRef cpTriggerElement) {
    setInitialColor(color);

    setColorMode(cpColorMode);

    _isIE10 = (detectIE() == 10);

    directiveInstance = instance;
    directiveElementRef = elementRef;

    cpDisableInput = cpDisableInput;

    cpCmykEnabled = cpCmykEnabled;
    cpAlphaChannel = cpAlphaChannel;
    cpOutputFormat = cpOutputFormat;

    cpDialogDisplay = cpDialogDisplay;

    cpIgnoredElements = cpIgnoredElements;

    cpSaveClickOutside = cpSaveClickOutside;
    cpCloseClickOutside = cpCloseClickOutside;

    useRootViewContainer = cpUseRootViewContainer;

    width = cpWidth = parseInt(cpWidth, 10);
    height = cpHeight = parseInt(cpHeight, 10);

    cpPosition = cpPosition;
    cpPositionOffset = parseInt(cpPositionOffset, 10);

    cpOKButton = cpOKButton;
    cpOKButtonText = cpOKButtonText;
    cpOKButtonClass = cpOKButtonClass;

    cpCancelButton = cpCancelButton;
    cpCancelButtonText = cpCancelButtonText;
    cpCancelButtonClass = cpCancelButtonClass;

    fallbackColor = cpFallbackColor ?? '#fff';

    setPresetConfig(cpPresetLabel, cpPresetColors);

    cpPresetColorsClass = cpPresetColorsClass;
    cpMaxPresetColorsLength = cpMaxPresetColorsLength;
    cpPresetEmptyMessage = cpPresetEmptyMessage;
    cpPresetEmptyMessageClass = cpPresetEmptyMessageClass;

    cpAddColorButton = cpAddColorButton;
    cpAddColorButtonText = cpAddColorButtonText;
    cpAddColorButtonClass = cpAddColorButtonClass;
    cpRemoveColorButtonClass = cpRemoveColorButtonClass;

    cpTriggerElement = cpTriggerElement;

    if (!cpPositionRelativeToArrow) {
      dialogArrowOffset = 0;
    }

    if (cpDialogDisplay == 'inline') {
      dialogArrowSize = 0;
      dialogArrowOffset = 0;
    }

    if (cpOutputFormat == 'hex' &&
        cpAlphaChannel != 'always' && cpAlphaChannel != 'forced') {
      cpAlphaChannel = 'disabled';
    }
  }

  void setColorMode(String mode) {
    switch (mode.toString().toUpperCase()) {
      case '1':
      case 'C':
      case 'COLOR':
        cpColorMode = 1;
        break;
      case '2':
      case 'G':
      case 'GRAYSCALE':
        cpColorMode = 2;
        break;
      case '3':
      case 'P':
      case 'PRESETS':
        cpColorMode = 3;
        break;
      default:
        cpColorMode = 1;
    }
  }

  void setInitialColor(Object color) {
    initialColor = color;
  }

  void setPresetConfig(String cpPresetLabel, Iterable<String> cpPresetColors) {
    cpPresetLabel = cpPresetLabel;
    cpPresetColors = cpPresetColors;
  }

  void setColorFromString(String value, [bool emit = true,
    bool update = true]) {
    Hsva hsva;

    if (cpAlphaChannel == 'always' || cpAlphaChannel == 'forced') {
      hsva = service.StringToHsva(value, true);

      if (!hsva && !hsva) {
        hsva = service.StringToHsva(value, false);
      }
    } else {
      hsva = service.StringToHsva(value, false);
    }

    if (!hsva && !hsva) {
      hsva = service.StringToHsva(fallbackColor, false);
    }

    if (hsva) {
      hsva = hsva;

      sliderH = hsva.h;

      if (cpOutputFormat == 'hex' && cpAlphaChannel == 'disabled') {
        hsva.a = 1;
      }

      updateColorPicker(emit, update);
    }
  }

  void onResize() {
    if (position == 'fixed') {
      setDialogPosition();
    } else if (cpDialogDisplay != 'inline') {
      closeColorPicker();
    }
  }

  void onDragEnd(String slider) {
    // directiveInstance.sliderDragEnd({ slider slider, this color.outputColor});
  }

  void onDragStart(String slider) {
// directiveInstance.sliderDragStart({  slider slider,  this color.outputColor });
  }

  void onMouseDown(MouseEvent event) {
    if (show &&
        !isIE10 && cpDialogDisplay == 'popup' &&
        event.target != directiveElementRef.nativeElement &&
        !isDescendant(elRef.nativeElement, event.target) &&
        !isDescendant(directiveElementRef.nativeElement, event.target) &&
        cpIgnoredElements
            .filter((Object item) => item == event.target)
            .length == 0) {
      if (cpSaveClickOutside) {
        directiveInstance.colorSelected(outputColor);
      } else {
        hsva = null;

        setColorFromString(initialColor, false);

        if (cpCmykEnabled) {
          directiveInstance.cmykChanged(cmykColor);
        }

        directiveInstance.colorChanged(initialColor);

        directiveInstance.colorCanceled();
      }

      if (cpCloseClickOutside) {
        closeColorPicker();
      }
    }
  }

  void onAcceptColor(Event event) {
    event.stopPropagation();

    if (outputColor) {
      directiveInstance.colorSelected(outputColor);
    }

    if (cpDialogDisplay == 'popup') {
      closeColorPicker();
    }
  }

  void onCancelColor(Event event) {
    hsva = null;

    event.stopPropagation();

    directiveInstance.colorCanceled();

    setColorFromString(initialColor, true);

    if (cpDialogDisplay == 'popup') {
      if (cpCmykEnabled) {
        directiveInstance.cmykChanged(cmykColor);
      }

      directiveInstance.colorChanged(initialColor, true);

      closeColorPicker();
    }
  }

  void onFormatToggle(num change) {
    const availableFormats = dialogInputFields.length -
        (cpCmykEnabled ? 0 : 1);

    const nextFormat = (((dialogInputFields.indexOf(format) + change) %
        availableFormats) + availableFormats) % availableFormats;

    format = dialogInputFields[nextFormat];
  }

  void onColorChange(dynamic value) {
    hsva.s = value.s / value.rgX;
    hsva.v = value.v / value.rgY;

    updateColorPicker();

    directiveInstance.sliderChanged({
      slider: 'lightness',
      this value.hsva.v,
      this color.outputColor
    });

    directiveInstance.sliderChanged({
      slider: 'saturation',
      this value.hsva.s,
      this color.outputColor
    });
  }

  void onHueChange(dynamic value) {
    hsva.h = value.v / value.rgX;
    sliderH = hsva.h;

    updateColorPicker();

    directiveInstance.sliderChanged({
      slider: 'hue',
      this value.hsva.h,
      this color.outputColor
    });
  }

  void onValueChange(dynamic value) {
    hsva.v = value.v / value.rgX;

    updateColorPicker();

// directiveInstance.sliderChanged({
// slider: 'value',
//  this value.hsva.v,
//  this color.outputColor
// });
  }

  void onAlphaChange(dynamic value) {
    hsva.a = value.v / value.rgX;

    updateColorPicker();

// directiveInstance.sliderChanged({
// slider: 'alpha',
//  this value.hsva.a,
//  this color.outputColor
// });
  }

  void onHexInput(String value) {
    if (value == null) {
      updateColorPicker();
    } else {
      if (value && value[0] != '#') {
        value = '#' + value;
      }

      final validHex = RegExp(
          r'^#([a-f0-9]{3}|[a-f0-9]{6})$', caseSensitive: false);

      if (cpAlphaChannel == 'always') {
        validHex = RegExp(
            r'^#([a-f0-9]{3}|[a-f0-9]{6}|[a-f0-9]{8})$', caseSensitive: false);
      }

      const valid = validHex.test(value);

      if (valid) {
        if (value.length < 5) {
          value = '#' + value.subString(1)
              .split('')
              .map((c) => c + c)
              .join('');
        }

        if (cpAlphaChannel == 'forced') {
          value += Math.round(hsva.a * 255).toString(16);
        }

        setColorFromString(value, true, false);
      }

// directiveInstance.inputChanged({
// input: 'hex',
//  valid valid,
//  value value,
//  this color.outputColor
// });
    }
  }

  void onRedInput(dynamic value) {
    const rgba = service.hsvaToRgba(hsva);

    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      rgba.r = value.v / value.rg;

      hsva = service.rgbaToHsva(rgba);

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'red',
//  valid valid,
//  rgba value.r,
//  this color.outputColor
// });
  }

  void onBlueInput(dynamic value) {
    const rgba = service.hsvaToRgba(hsva);

    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      rgba.b = value.v / value.rg;

      hsva = service.rgbaToHsva(rgba);

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'blue',
//  valid valid,
//  rgba value.b,
//  this color.outputColor
// });
  }

  void onGreenInput(dynamic value) {
    const rgba = service.hsvaToRgba(hsva);

    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      rgba.g = value.v / value.rg;

      hsva = service.rgbaToHsva(rgba);

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'green',
//  valid valid,
//  rgba value.g,
//  this color.outputColor
// });
  }

  void onHueInput(dynamic value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      hsva.h = value.v / value.rg;

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'hue',
//  valid valid,
//  this value.hsva.h,
//  this color.outputColor
// });
  }

  void onValueInput(value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      hsva.v = value.v / value.rg;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'value',
//  valid valid,
//  this value.hsva.v,
//  this color.outputColor
// });
  }

  void onAlphaInput(dynamic value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      hsva.a = value.v / value.rg;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'alpha',
//  valid valid,
//  this value.hsva.a,
//  this color.outputColor
// });
  }

  void onLightnessInput(value) {
    const hsla = service.hsva2hsla(hsva);

    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      hsla.l = value.v / value.rg;

      hsva = service.hsla2hsva(hsla);

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'lightness',
//  valid valid,
//  hsla value.l,
//  this color.outputColor
// });
  }

  void onSaturationInput(dynamic value) {
    const hsla = service.hsva2hsla(hsva);

    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      hsla.s = value.v / value.rg;

      hsva = service.hsla2hsva(hsla);

      sliderH = hsva.h;

      updateColorPicker();
    }

// directiveInstance.inputChanged({
// input: 'saturation',
//  valid valid,
//  hsla value.s,
//  this color.outputColor
// });
  }

  void onCyanInput(dynamic value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      cmyk.c = value.v;

      updateColorPicker(false, true, true);
    }

// directiveInstance.inputChanged({
// input: 'cyan',
//  true valid,
//  this value.cmyk.c,
//  this color.outputColor
// });
  }

  void onMagentaInput(dynamic value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      cmyk.m = value.v;

      updateColorPicker(false, true, true);
    }

// directiveInstance.inputChanged({
// input: 'magenta',
//  true valid,
//  this value.cmyk.m,
//  this color.outputColor
// });
  }

  void onYellowInput(dynamic value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      cmyk.y = value.v;

      updateColorPicker(false, true, true);
    }

// directiveInstance.inputChanged({
// input: 'yellow',
//  true valid,
//  this value.cmyk.y,
//  this color.outputColor
// });
  }

  void onBlackInput(value) {
    const valid = !isNaN(value.v) && value.v >= 0 && value.v <= value.rg;

    if (valid) {
      cmyk.k = value.v;

      updateColorPicker(false, true, true);
    }

// directiveInstance.inputChanged({
// input: 'black',
//  true valid,
//  this value.cmyk.k,
//  this color.outputColor
// });
  }

  void onAddPresetColor(Object event, String value) {
    event.stopPropagation();

    if (!cpPresetColors
        .filter((color) => (color == value))
        .length) {
      cpPresetColors = cpPresetColors.concat(value);

      directiveInstance.presetColorsChanged(cpPresetColors);
    }
  }

  void onRemovePresetColor(Object event, String value) {
    event.stopPropagation();

    cpPresetColors = cpPresetColors.filter((color) => (color != value));

    directiveInstance.presetColorsChanged(cpPresetColors);
  }

// _helper functions for the color picker dialog status

  void _openColorPicker() {
    if (!show) {
      show = true;
      hidden = true;

      setTimeout(() {
        hidden = false;

        setDialogPosition();

        cdRef.detectChanges();
      }, 0);

      directiveInstance.stateChanged(true);

      if (!isIE10) {
        document.addEventListener('mousedown', listenerMouseDown);
        document.addEventListener('touchstart', listenerMouseDown);
      }

      window.addEventListener('resize', listenerResize);
    }
  }

  void _closeColorPicker() {
    if (show) {
      show = false;

      directiveInstance.stateChanged(false);

      if (!isIE10) {
        document.removeEventListener('mousedown', listenerMouseDown);
        document.removeEventListener('touchstart', listenerMouseDown);
      }

      window.removeEventListener('resize', listenerResize);

      if (!cdRef['destroyed']) {
        cdRef.detectChanges();
      }
    }
  }

  void _updateColorPicker(
      [bool emit = true, bool update = true, bool cmykInput = false]) {
    if (sliderDimMax) {
      if (cpColorMode == 2) {
        hsva.s = 0;
      }

      Rgba hue;
      Hsla hsla;
      Rgba rgba;

      const lastOutput = outputColor;

      hsla = service.hsva2hsla(hsva);

      if (!cpCmykEnabled) {
        rgba = service.denormalizeRGBA(service.hsvaToRgba(hsva));
      } else {
        if (!cmykInput) {
          rgba = service.hsvaToRgba(hsva);

          cmyk = service.denormalizeCMYK(service.rgbaToCmyk(rgba));
        } else {
          rgba = service.cmykToRgb(service.normalizeCMYK(cmyk));

          hsva = service.rgbaToHsva(rgba);
        }

        rgba = service.denormalizeRGBA(rgba);

        sliderH = hsva.h;
      }

      hue = service.denormalizeRGBA(
          service.hsvaToRgba(new Hsva(sliderH || hsva.h, 1, 1, 1)));

      if (update) {
        hslaText =
        new Hsla(Math.round((hsla.h) * 360), Math.round(hsla.s * 100),
            Math.round(hsla.l * 100),
            Math.round(hsla.a * 100) / 100);

        rgbaText =
        new Rgba(rgba.r, rgba.g, rgba.b, Math.round(rgba.a * 100) / 100);

        if (cpCmykEnabled) {
          cmykText = new Cmyk(cmyk.c, cmyk.m, cmyk.y, cmyk.k,
              Math.round(cmyk.a * 100) / 100);
        }

        const allowHex8 = cpAlphaChannel == 'always';

        hexText = service.rgbaToHex(rgba, allowHex8);
        hexAlpha = rgbaText.a;
      }

      if (cpOutputFormat == 'auto') {
        if (format != ColorFormats.RGBA && format != ColorFormats.CMYK) {
          if (hsva.a < 1) {
            format = hsva.a < 1 ? ColorFormats.RGBA : ColorFormats.HEX;
          }
        }
      }

      hueSliderColor = 'rgb(' + hue.r + ',' + hue.g + ',' + hue.b + ')';
      alphaSliderColor = 'rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')';

      outputColor = service.outputFormat(hsva, cpOutputFormat, cpAlphaChannel);
      selectedColor = service.outputFormat(hsva, 'rgba', null);

      if (format != ColorFormats.CMYK) {
        cmykColor = '';
      } else {
        if (cpAlphaChannel == 'always' || cpAlphaChannel == 'enabled' ||
            cpAlphaChannel == 'forced') {
          const alpha = Math.round(cmyk.a * 100) / 100;

          cmykColor = `
          cmyka(${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k}, ${alpha})`;
        } else {
          cmykColor = `
          cmyk(${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k})`;
        }
      }

      slider = new SliderPosition(
          (sliderH || hsva.h) * sliderDimMax.h - 8,
          hsva.s * sliderDimMax.s - 8,
          (1 - hsva.v) * sliderDimMax.v - 8,
          hsva.a * sliderDimMax.a - 8
      );

      if (emit && lastOutput != outputColor) {
        if (cpCmykEnabled) {
          directiveInstance.cmykChanged(cmykColor);
        }

        directiveInstance.colorChanged(outputColor);
      }
    }
  }

// _helper functions for the color picker dialog positioning

  void _setDialogPosition() {
    if (cpDialogDisplay == 'inline') {
      position = 'relative';
    } else {
      var position = 'static',
          transform = '',
          style;

      Object parentNode;
      Object transformNode;

      var node = directiveElementRef.nativeElement.parentNode;

      var dialogHeight = dialogElement.nativeElement.offsetHeight;

      while (node != null && node.tagName != 'HTML') {
        style = window.getComputedStyle(node);
        position = style.getPropertyValue('position');
        transform = style.getPropertyValue('transform');

        if (position != 'static' && parentNode == null) {
          parentNode = node;
        }

        if (transform && transform != 'none' && transformNode == null) {
          transformNode = node;
        }

        if (position == 'fixed') {
          parentNode = transformNode;

          break;
        }

        node = node.parentNode;
      }

      var boxDirective = createDialogBox(
          directiveElementRef.nativeElement, (position != 'fixed'));

      if (useRootViewContainer || (position == 'fixed' &&
          (!parentNode || parentNode instanceof HTMLUnknownElement))) {
        top = boxDirective.top;
        left = boxDirective.left;
      } else {
        if (parentNode == null) {
          parentNode = node;
        }

        final boxParent = createDialogBox(parentNode, (position != 'fixed'));

        top = boxDirective.top - boxParent.top;
        left = boxDirective.left - boxParent.left;
      }

      if (position == 'fixed') {
        position = 'fixed';
      }

      var usePosition = cpPosition;

      if (cpPosition == 'auto') {
        final dialogBounds = dialogElement.nativeElement
            .getBoundingClientRect();
        final triggerBounds = cpTriggerElement.nativeElement
            .getBoundingClientRect();
        usePosition = calculateAutoPositioning(dialogBounds, triggerBounds);
      }

      if (usePosition == 'top') {
        arrowTop = dialogHeight - 1;

        top -= dialogHeight + dialogArrowSize;
        left += cpPositionOffset / 100 * boxDirective.width - dialogArrowOffset;
      } else if (usePosition == 'bottom') {
        top += boxDirective.height + dialogArrowSize;
        left += cpPositionOffset / 100 * boxDirective.width - dialogArrowOffset;
      } else if (usePosition == 'top-left' || usePosition == 'left-top') {
        top -= dialogHeight - boxDirective.height +
            boxDirective.height * cpPositionOffset / 100;
        left -= cpWidth + dialogArrowSize - 2 - dialogArrowOffset;
      } else if (usePosition == 'top-right' || usePosition == 'right-top') {
        top -= dialogHeight - boxDirective.height +
            boxDirective.height * cpPositionOffset / 100;
        left += boxDirective.width + dialogArrowSize - 2 - dialogArrowOffset;
      } else if (usePosition == 'left' || usePosition == 'bottom-left' ||
          usePosition == 'left-bottom') {
        top += boxDirective.height * cpPositionOffset / 100 - dialogArrowOffset;
        left -= cpWidth + dialogArrowSize - 2;
      } else { // usePosition == 'right' || usePosition == 'bottom-right' || usePosition == 'right-bottom'
        top += boxDirective.height * cpPositionOffset / 100 - dialogArrowOffset;
        left += boxDirective.width + dialogArrowSize - 2;
      }

      cpUsePosition = usePosition;
    }
  }

  String calculateAutoPositioning(Rectangle elBounds,
      Rectangle triggerElBounds) {
    // Defaults
    var usePositionX = 'right';
    var usePositionY = 'bottom';
    // Calculate collisions
    final height = elBounds.height;
    final width = elBounds.width;
    final top = triggerElBounds.top;
    final left = triggerElBounds.left;
    final bottom = top + triggerElBounds.height;
    final right = left + triggerElBounds.width;

    final collisionTop = top - height < 0;
    final collisionBottom = bottom + height >
        (window.innerHeight ?? document.documentElement.clientHeight);
    final collisionLeft = left - width < 0;
    final collisionRight = right + width >
        (window.innerWidth ?? document.documentElement.clientWidth);
    final collisionAll = collisionTop && collisionBottom && collisionLeft &&
        collisionRight;

// Generate X & Y position values
    if (collisionBottom) {
      usePositionY = 'top';
    }

    if (collisionTop) {
      usePositionY = 'bottom';
    }

    if (collisionLeft) {
      usePositionX = 'right';
    }

    if (collisionRight) {
      usePositionX = 'left';
    }


// Choose the largest gap available
    if (collisionAll) {
      const postions = ['left', 'right', 'top', 'bottom'];
      return postions.reduce((prev, next) =>
      elBounds[prev] > elBounds[next]
          ? prev
          : next);
    }

    if ((collisionLeft && collisionRight)) {
      if (collisionTop) {
        return 'bottom';
      }
      if (collisionBottom) {
        return 'top';
      }
      return top > bottom ? 'top' : 'bottom';
    }

    if ((collisionTop && collisionBottom)) {
      if (collisionLeft) {
        return 'right';
      }
      if (collisionRight) {
        return 'left';
      }
      return left > right ? 'left' : 'right';
    }

    return '${usePositionY}-${usePositionX}';
  }
}
