
class Rgba {
  int r, g, b, a;

  Rgba(
    this.r, this.g, this.b, this.a
  );
}

class Hsva {
  int h, s, v, a;

  Hsva(this.h, this.s, this.v, this.a);

  Hsla toHsla() {
    if (v == 0) {
      return Hsla(h, 0, 0, a);
    } else if (s == 0 && v == 1) {
      return Hsla(h, 1, 1, a);
    } else {
      final l = v * (2 - s) / 2;

      return Hsla(h, (v * s / (1 - (2 * l - 1).abs())).round(), l.round(), a);
    }
  }

  String outputFormat(String outputFormat, String alphaChannel) {
    if (outputFormat == 'auto') {
      outputFormat = a < 1 ? 'rgba' : 'hex';
    }

    switch (outputFormat) {
      case 'hsla':
        final hsla = toHsla();
        final hslaText = Hsla(((hsla.h) * 360), hsla.s * 100,
            hsla.l * 100, ((hsla.a * 100) / 100).round());

        if (a < 1 || alphaChannel == 'always') {
          return 'hsla(${hslaText.h},${hslaText.s}%,${
              hslaText.l}%,${hslaText.a})';
        } else {
          return 'hsl(${hslaText.h},${hslaText.s}%,${hslaText.l}%)';
        }
      case 'rgba':
        final rgba = denormalizeRGBA(hsvaToRgba(hsva));

        if (a < 1 || alphaChannel == 'always') {
          return 'rgba(${rgba.r},${rgba.g},${rgba.b},${(rgba.a * 100) / 100})';
        } else {
          return 'rgb(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ')';
        }

      default:
        final allowHex8 = (alphaChannel == 'always' ||
            alphaChannel == 'forced');

        return rgbaToHex(denormalizeRGBA(hsvaToRgba(hsva)), allowHex8);
    }
  }
}

class Hsla {
  int h, s, l, a;

  Hsla(
    this.h, this.s, this.l, this.a
  );
}

class Cmyk {
  num c, m, y, k, a;

  Cmyk(
    this.c, this.m, this.y, this.k, {this.a = 1}
  );
}
